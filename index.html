<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>angel devil's pool</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;500;600;700&family=DM+Mono:wght@400;500&family=DM+Sans:wght@300;400;500&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #1a1f2e;
    --bg2: #1f2535;
    --bg3: #252c3d;
    --bg4: #2d3650;
    --border: #3a4460;
    --border-bright: #4a5880;
    --accent: #5b8dee;
    --accent-glow: rgba(91,141,238,0.15);
    --text: #d8e0f0;
    --text-dim: #8896b3;
    --text-bright: #eef2ff;
    --nm: #6ec6f5;
    --hd: #f5c56e;
    --hr: #f57a6e;
    --dt: #a56ef5;
    --fm: #6ef5b2;
    --tb: #f56ea8;
  }

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'DM Sans', sans-serif;
    min-height: 100vh;
    overflow-x: hidden;
  }

  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background-image:
      linear-gradient(var(--border) 1px, transparent 1px),
      linear-gradient(90deg, var(--border) 1px, transparent 1px);
    background-size: 40px 40px;
    opacity: 0.12;
    pointer-events: none;
    z-index: 0;
  }

  .container {
    position: relative;
    z-index: 1;
    max-width: 1000px;
    margin: 0 auto;
    padding: 48px 24px 80px;
  }

  header { margin-bottom: 48px; }

  .logo-row {
    display: flex;
    align-items: baseline;
    gap: 12px;
    margin-bottom: 6px;
  }

  h1 {
    font-family: 'Rajdhani', sans-serif;
    font-size: 2.8rem;
    font-weight: 700;
    letter-spacing: 0.04em;
    color: var(--text-bright);
    text-transform: uppercase;
  }

  .version-tag {
    font-family: 'DM Mono', monospace;
    font-size: 0.7rem;
    color: var(--accent);
    background: var(--accent-glow);
    border: 1px solid rgba(91,141,238,0.3);
    padding: 2px 8px;
    border-radius: 3px;
    letter-spacing: 0.1em;
  }

  .subtitle { font-size: 0.85rem; color: var(--text-dim); letter-spacing: 0.05em; }

  /* Search */
  .search-section { margin-bottom: 40px; }

  .search-label {
    font-family: 'DM Mono', monospace;
    font-size: 0.7rem;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: var(--text-dim);
    margin-bottom: 8px;
    display: block;
  }

  .search-wrapper { position: relative; max-width: 560px; }

  .search-input {
    width: 100%;
    background: var(--bg3);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 12px 16px 12px 44px;
    font-family: 'DM Sans', sans-serif;
    font-size: 0.95rem;
    color: var(--text-bright);
    outline: none;
    transition: border-color 0.2s, box-shadow 0.2s;
  }

  .search-input:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 3px var(--accent-glow);
  }

  .search-input::placeholder { color: var(--text-dim); }

  .search-icon {
    position: absolute;
    left: 14px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--text-dim);
    pointer-events: none;
  }

  .dropdown {
    position: absolute;
    top: calc(100% + 6px);
    left: 0;
    right: 0;
    background: var(--bg3);
    border: 1px solid var(--border-bright);
    border-radius: 8px;
    max-height: 280px;
    overflow-y: auto;
    z-index: 100;
    display: none;
    box-shadow: 0 8px 32px rgba(0,0,0,0.4);
  }

  .dropdown.open { display: block; }
  .dropdown::-webkit-scrollbar { width: 5px; }
  .dropdown::-webkit-scrollbar-track { background: transparent; }
  .dropdown::-webkit-scrollbar-thumb { background: var(--border-bright); border-radius: 3px; }

  .dropdown-item {
    padding: 10px 16px;
    cursor: pointer;
    font-size: 0.9rem;
    color: var(--text);
    transition: background 0.1s, color 0.1s;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .dropdown-item:last-child { border-bottom: none; }
  .dropdown-item:hover, .dropdown-item.active { background: var(--bg4); color: var(--text-bright); }

  .dropdown-item .pool-name {
    font-family: 'Rajdhani', sans-serif;
    font-weight: 600;
    font-size: 1rem;
    letter-spacing: 0.03em;
  }

  .dropdown-item .pool-elo {
    font-family: 'DM Mono', monospace;
    font-size: 0.7rem;
    color: var(--text-dim);
    margin-left: auto;
  }

  .status-bar {
    font-family: 'DM Mono', monospace;
    font-size: 0.72rem;
    color: var(--text-dim);
    margin-top: 8px;
    height: 18px;
    transition: color 0.3s;
  }

  .status-bar.loading { color: var(--accent); }
  .status-bar.error   { color: #f57a6e; }
  .status-bar.ok      { color: #6ef5b2; }

  /* Pool view */
  .pool-view { display: none; animation: fadeUp 0.3s ease; }
  .pool-view.visible { display: block; }

  @keyframes fadeUp {
    from { opacity: 0; transform: translateY(12px); }
    to   { opacity: 1; transform: translateY(0); }
  }

  .pool-header {
    display: flex;
    align-items: baseline;
    gap: 16px;
    margin-bottom: 28px;
    padding-bottom: 16px;
    border-bottom: 1px solid var(--border);
  }

  .pool-title {
    font-family: 'Rajdhani', sans-serif;
    font-size: 2rem;
    font-weight: 700;
    color: var(--text-bright);
    letter-spacing: 0.05em;
    text-transform: uppercase;
  }

  .pool-meta {
    font-family: 'DM Mono', monospace;
    font-size: 0.72rem;
    color: var(--text-dim);
  }

  /* Multiple pools */
  .pools-container { display: flex; flex-direction: column; gap: 0; }

  .pool-block {
    animation: slideDown 0.4s cubic-bezier(0.22, 1, 0.36, 1);
    transform-origin: top;
  }

  @keyframes slideDown {
    from {
      opacity: 0;
      transform: translateY(-24px) scaleY(0.97);
    }
    to {
      opacity: 1;
      transform: translateY(0) scaleY(1);
    }
  }

  .pool-block.removing {
    animation: slideUp 0.35s cubic-bezier(0.4, 0, 1, 1) forwards;
    overflow: hidden;
  }

  @keyframes slideUp {
    from {
      opacity: 1;
      transform: translateY(0) scaleY(1);
      max-height: 2000px;
    }
    to {
      opacity: 0;
      transform: translateY(-16px) scaleY(0.95);
      max-height: 0;
      margin: 0;
      padding: 0;
    }
  }

  .pool-divider {
    animation: fadeIn 0.3s ease 0.1s both;
  }

  .pool-divider.removing {
    animation: fadeOut 0.25s ease forwards;
  }

  @keyframes fadeIn {
    from { opacity: 0; }
    to   { opacity: 1; }
  }

  @keyframes fadeOut {
    from { opacity: 1; }
    to   { opacity: 0; }
  }

  .pool-divider {
    display: flex;
    align-items: center;
    gap: 16px;
    margin: 40px 0;
  }

  .pool-divider-line {
    flex: 1;
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--border-bright), transparent);
  }

  .pool-divider-label {
    font-family: 'DM Mono', monospace;
    font-size: 0.65rem;
    letter-spacing: 0.15em;
    color: var(--border-bright);
    text-transform: uppercase;
  }

  .pool-block-header {
    display: flex;
    align-items: baseline;
    justify-content: space-between;
    gap: 16px;
    margin-bottom: 28px;
    padding-bottom: 16px;
    border-bottom: 1px solid var(--border);
  }

  .pool-block-header-left {
    display: flex;
    align-items: baseline;
    gap: 16px;
  }

  .pool-remove-btn {
    font-family: 'DM Mono', monospace;
    font-size: 0.65rem;
    letter-spacing: 0.1em;
    color: var(--text-dim);
    background: none;
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 3px 10px;
    cursor: pointer;
    transition: border-color 0.15s, color 0.15s;
    flex-shrink: 0;
  }

  .pool-remove-btn:hover { border-color: #f57a6e; color: #f57a6e; }

  /* Category sections */
  .category-section { margin-bottom: 32px; }

  .category-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
  }

  .category-pill {
    font-family: 'Rajdhani', sans-serif;
    font-size: 0.85rem;
    font-weight: 700;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    padding: 3px 12px;
    border-radius: 4px;
    border: 1px solid;
  }

  .cat-nm .category-pill { color: var(--nm); border-color: var(--nm); background: rgba(110,198,245,0.08); }
  .cat-hd .category-pill { color: var(--hd); border-color: var(--hd); background: rgba(245,197,110,0.08); }
  .cat-hr .category-pill { color: var(--hr); border-color: var(--hr); background: rgba(245,122,110,0.08); }
  .cat-dt .category-pill { color: var(--dt); border-color: var(--dt); background: rgba(165,110,245,0.08); }
  .cat-fm .category-pill { color: var(--fm); border-color: var(--fm); background: rgba(110,245,178,0.08); }
  .cat-tb .category-pill { color: var(--tb); border-color: var(--tb); background: rgba(245,110,168,0.08); }

  .category-count {
    font-family: 'DM Mono', monospace;
    font-size: 0.7rem;
    color: var(--text-dim);
  }

  /* Map rows */
  .map-list { display: flex; flex-direction: column; gap: 6px; }

  .map-row {
    display: flex;
    align-items: stretch;
    background: var(--bg2);
    border: 1px solid var(--border);
    border-radius: 6px;
    overflow: hidden;
    transition: border-color 0.15s, background 0.15s;
    position: relative;
    min-height: 72px;
  }

  .map-row::before {
    content: '';
    position: absolute;
    left: 0; top: 0; bottom: 0;
    width: 3px;
    z-index: 2;
  }

  .cat-nm .map-row::before { background: var(--nm); }
  .cat-hd .map-row::before { background: var(--hd); }
  .cat-hr .map-row::before { background: var(--hr); }
  .cat-dt .map-row::before { background: var(--dt); }
  .cat-fm .map-row::before { background: var(--fm); }
  .cat-tb .map-row::before { background: var(--tb); }

  .map-row:hover { border-color: var(--border-bright); background: var(--bg3); }

  /* Cover image */
  .map-cover {
    width: 108px;
    min-width: 108px;
    background: var(--bg4);
    position: relative;
    overflow: hidden;
    flex-shrink: 0;
  }

  .map-cover img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    position: relative;
    z-index: 1;
    opacity: 0;
    transition: opacity 0.35s;
  }

  .map-cover img.loaded { opacity: 1; }

  .map-cover-placeholder {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--border);
    z-index: 0;
  }

  .map-cover img {
    position: relative;
    z-index: 1;
  }

  .map-num {
    position: absolute;
    bottom: 4px;
    right: 6px;
    font-family: 'DM Mono', monospace;
    font-size: 0.62rem;
    color: rgba(255,255,255,0.55);
    z-index: 2;
    text-shadow: 0 1px 4px rgba(0,0,0,0.9);
  }

  /* Map body */
  .map-body {
    flex: 1;
    padding: 11px 16px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    gap: 5px;
    min-width: 0;
  }

  .map-title-row {
    display: flex;
    align-items: baseline;
    gap: 0;
    flex-wrap: nowrap;
    min-width: 0;
  }

  .map-title {
    font-family: 'Rajdhani', sans-serif;
    font-size: 1.05rem;
    font-weight: 600;
    color: var(--text-bright);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    min-width: 0;
  }

  .map-sep {
    color: var(--border-bright);
    font-size: 0.85rem;
    padding: 0 10px;
    flex-shrink: 0;
  }

  .map-score {
    font-family: 'DM Mono', monospace;
    font-size: 0.8rem;
    white-space: nowrap;
    flex-shrink: 0;
  }

  .map-sub-row {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .map-sr, .map-bpm {
    font-family: 'DM Mono', monospace;
    font-size: 0.72rem;
    color: var(--text-dim);
  }

  .map-sub-sep {
    color: var(--border);
    font-size: 0.7rem;
  }

  .map-comment {
    font-size: 0.78rem;
    color: var(--text-dim);
    font-style: italic;
    line-height: 1.4;
  }

  .map-loading {
    font-family: 'DM Mono', monospace;
    font-size: 0.75rem;
    color: var(--text-dim);
    animation: blink 1.2s ease-in-out infinite;
  }

  @keyframes blink {
    0%, 100% { opacity: 0.3; }
    50%       { opacity: 0.8; }
  }

  /* Score colours handled via inline style from getScoreColor() */

  /* Empty / cache */
  .empty-state {
    text-align: center;
    padding: 80px 24px;
    color: var(--text-dim);
  }

  .empty-state svg { opacity: 0.2; margin-bottom: 16px; }

  .empty-state p {
    font-family: 'DM Mono', monospace;
    font-size: 0.8rem;
    letter-spacing: 0.1em;
  }

  .cache-badge {
    display: inline-flex;
    align-items: center;
    gap: 5px;
    font-family: 'DM Mono', monospace;
    font-size: 0.65rem;
    letter-spacing: 0.1em;
    color: var(--text-dim);
    background: var(--bg3);
    border: 1px solid var(--border);
    padding: 2px 8px;
    border-radius: 3px;
    cursor: pointer;
    transition: border-color 0.2s, color 0.2s;
    margin-left: 8px;
  }

  .cache-badge:hover { border-color: var(--border-bright); color: var(--text); }

  .cache-badge .dot {
    width: 5px; height: 5px;
    border-radius: 50%;
    background: #6ef5b2;
  }

  .cache-badge .dot.stale { background: #f5c56e; }

  /* ── Activity Chart ─────────────────────────────────────────────────────── */
  .activity-section {
    margin-top: 64px;
    padding-top: 8px;
  }

  .activity-divider {
    display: flex;
    align-items: center;
    gap: 16px;
    margin-bottom: 28px;
  }

  .activity-chart-wrap {
    display: flex;
    flex-direction: column;
    gap: 0;
  }

  .activity-chart {
    display: flex;
    align-items: flex-end;
    gap: 3px;
    height: 100px;
    padding-bottom: 0;
  }

  .activity-bar-col {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    justify-content: flex-end;
    height: 100%;
    gap: 0;
    position: relative;
    cursor: default;
  }

  .activity-bar-seg {
    width: 100%;
    min-height: 1px;
    border-radius: 0;
    transition: filter 0.15s, opacity 0.15s;
  }

  .activity-bar-seg:hover, .activity-bar-seg.hovered {
    filter: brightness(1.35);
  }

  .activity-bar-empty {
    flex: 1;
    width: 100%;
    background: var(--bg3);
    border-radius: 3px;
    opacity: 0.35;
    min-height: 4px;
  }

  .activity-x-labels {
    display: flex;
    gap: 3px;
    margin-top: 6px;
  }

  .activity-x-label {
    flex: 1;
    font-family: 'DM Mono', monospace;
    font-size: 0.55rem;
    color: var(--text-dim);
    text-align: center;
    overflow: hidden;
    white-space: nowrap;
  }

  .activity-legend {
    display: flex;
    flex-wrap: wrap;
    gap: 12px 20px;
    margin-top: 16px;
  }

  .activity-legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-family: 'DM Mono', monospace;
    font-size: 0.65rem;
    color: var(--text-dim);
    letter-spacing: 0.08em;
  }

  .activity-legend-dot {
    width: 8px;
    height: 8px;
    border-radius: 2px;
    flex-shrink: 0;
  }

  .activity-tooltip {
    position: fixed;
    background: var(--bg4);
    border: 1px solid var(--border-bright);
    border-radius: 6px;
    padding: 8px 12px;
    font-family: 'DM Mono', monospace;
    font-size: 0.7rem;
    color: var(--text);
    pointer-events: none;
    z-index: 9999;
    box-shadow: 0 4px 16px rgba(0,0,0,0.4);
    display: none;
    min-width: 120px;
    line-height: 1.7;
  }

  /* ── Score Drill-Down Modal ──────────────────────────────────────────────── */
  .score-modal-backdrop {
    position: fixed;
    inset: 0;
    background: rgba(10, 13, 22, 0.82);
    backdrop-filter: blur(4px);
    z-index: 10000;
    display: flex;
    align-items: flex-start;
    justify-content: center;
    padding: 48px 24px;
    overflow-y: auto;
    animation: backdropIn 0.18s ease;
  }

  @keyframes backdropIn {
    from { opacity: 0; }
    to   { opacity: 1; }
  }

  .score-modal {
    background: var(--bg2);
    border: 1px solid var(--border-bright);
    border-radius: 10px;
    width: 100%;
    max-width: 760px;
    box-shadow: 0 24px 64px rgba(0,0,0,0.6);
    animation: modalIn 0.22s cubic-bezier(0.22, 1, 0.36, 1);
    overflow: hidden;
  }

  @keyframes modalIn {
    from { opacity: 0; transform: translateY(16px) scale(0.98); }
    to   { opacity: 1; transform: translateY(0) scale(1); }
  }

  .score-modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 18px 22px 16px;
    border-bottom: 1px solid var(--border);
    gap: 12px;
  }

  .score-modal-header-left {
    display: flex;
    align-items: center;
    gap: 12px;
    min-width: 0;
  }

  .score-modal-title {
    font-family: 'Rajdhani', sans-serif;
    font-size: 1.4rem;
    font-weight: 700;
    letter-spacing: 0.05em;
    text-transform: uppercase;
    color: var(--text-bright);
  }

  .score-modal-meta {
    font-family: 'DM Mono', monospace;
    font-size: 0.7rem;
    color: var(--text-dim);
    white-space: nowrap;
  }

  .score-modal-close {
    font-family: 'DM Mono', monospace;
    font-size: 0.65rem;
    letter-spacing: 0.1em;
    color: var(--text-dim);
    background: none;
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 4px 12px;
    cursor: pointer;
    transition: border-color 0.15s, color 0.15s;
    flex-shrink: 0;
  }

  .score-modal-close:hover { border-color: #f57a6e; color: #f57a6e; }

  .score-modal-body {
    padding: 20px 22px 24px;
    display: flex;
    flex-direction: column;
    gap: 28px;
  }

  .score-modal-tab-section { display: flex; flex-direction: column; gap: 0; }

  .score-modal-tab-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
  }

  .score-modal-no-detail {
    font-family: 'DM Mono', monospace;
    font-size: 0.75rem;
    color: var(--text-dim);
    padding: 16px 0;
    text-align: center;
  }
</style>
</head>
<body>
<div class="activity-tooltip" id="activityTooltip"></div>
<div id="scoreModalBackdrop" class="score-modal-backdrop" style="display:none" onclick="handleModalBackdropClick(event)">
  <div class="score-modal" id="scoreModal">
    <div class="score-modal-header">
      <div class="score-modal-header-left">
        <div class="score-modal-title" id="scoreModalTitle"></div>
        <div class="score-modal-meta" id="scoreModalMeta"></div>
      </div>
      <button class="score-modal-close" onclick="closeScoreModal()">✕ CLOSE</button>
    </div>
    <div class="score-modal-body" id="scoreModalBody"></div>
  </div>
</div>
<div class="container">
  <header>
    <div class="logo-row">
      <h1>angel devil's pool viewer</h1>
      <span class="version-tag">BETA</span>
      <span id="cacheBadgePools" class="cache-badge" onclick="clearPoolsCache()" title="Click to clear pools cache">
        <span class="dot" id="cacheDotPools"></span>
        <span id="cacheLabelPools">POOLS</span>
      </span>
      <span id="cacheBadgeScores" class="cache-badge" onclick="clearScoresCache()" title="Click to clear scores cache">
        <span class="dot" id="cacheDotScores"></span>
        <span id="cacheLabelScores">SCORES</span>
      </span>
    </div>
    <p class="subtitle">Search a pool to view its maps and scores</p>
  </header>

  <div class="search-section">
    <label class="search-label" for="poolSearch">Pool Name</label>
    <div class="search-wrapper">
      <svg class="search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/>
      </svg>
      <input type="text" id="poolSearch" class="search-input" placeholder="Type to search pools..." autocomplete="off" spellcheck="false"/>
      <div class="dropdown" id="dropdown"></div>
    </div>
    <div class="status-bar" id="statusBar">Initializing...</div>
  </div>

  <div class="pool-view" id="poolView">
    <div class="pools-container" id="poolsContainer"></div>
  </div>

  <div class="empty-state" id="emptyState">
    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
      <rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18M9 21V9"/>
    </svg>
    <p>NO POOL SELECTED</p>
  </div>

  <!-- Activity bar chart -->
  <div class="activity-section" id="activitySection" style="display:none">
    <div class="activity-divider">
      <div class="pool-divider-line"></div>
      <span class="pool-divider-label">activity — last 30 days</span>
      <div class="pool-divider-line"></div>
    </div>
    <div class="activity-chart-wrap">
      <div class="activity-chart" id="activityChart"></div>
      <div class="activity-x-labels" id="activityXLabels"></div>
    </div>
    <div class="activity-legend" id="activityLegend"></div>
  </div>
</div>

<script>
// ─── CONFIG ───────────────────────────────────────────────────────────────────
const PROXY        = 'https://script.google.com/macros/s/AKfycbw0SPAR00YU0X2Z1RplLSj5ExUvUtDJEzwXScy5JVbD0GhrsZbRIl0bvNjAt_h0uaXn/exec';
const POOL_TABS = [
  { name: '1500', gid: '0' },
  { name: '1600', gid: '1078875662' },
  { name: '1700', gid: '1788254711' },
  { name: '1800', gid: '1253646153' },
];
const SCORE_TABS = [
  { name: 'nm1',   gid: '868418815' },
  { name: 'nm2',   gid: '458630398' },
  { name: 'nm3',   gid: '2021670014' },
  { name: 'nm4',   gid: '1137615268' },
  { name: 'nm5/6', gid: '1412097864' },
  { name: 'hd1',   gid: '1280354368' },
  { name: 'hd2',   gid: '326502377' },
  { name: 'hr1',   gid: '811694452' },
  { name: 'hr2',   gid: '2053745936' },
  { name: 'hr3',   gid: '1944906320' },
  { name: 'dt1',   gid: '1284559838' },
  { name: 'dt2/3', gid: '1353339214' },
];
const CACHE_KEY_POOLS  = 'mpool_pools_v1';
const CACHE_KEY_SCORES = 'mpool_scores_v7';
const CACHE_TTL_POOLS  = 60 * 60 * 1000;  // 1 hour (pools rarely change)
const CACHE_TTL_SCORES = 10 * 60 * 1000;  // 10 minutes (scores update often)
// Cols (0-indexed): B=1 image, C=2 name, D=3 score, E=4 difficulty, F=5 bpm, I=8 map ID

// ─── STATE ────────────────────────────────────────────────────────────────────
let poolsData = [];
let scoresMap = {};      // keyed by "tabName:mapId" — only rows with valid map IDs
let chartEntries = [];   // all rows with a date, regardless of map ID — used by activity chart

// ─── CSV ──────────────────────────────────────────────────────────────────────
function parseCSV(text) {
  return text.trim().split('\n').map(line => {
    const cols = []; let cur = '', inQ = false;
    for (let i = 0; i < line.length; i++) {
      const c = line[i];
      if (c === '"') { inQ = !inQ; }
      else if (c === ',' && !inQ) { cols.push(cur.trim()); cur = ''; }
      else cur += c;
    }
    cols.push(cur.trim());
    return cols;
  });
}

// ─── CACHE ────────────────────────────────────────────────────────────────────
function savePoolsCache(data) {
  try { localStorage.setItem(CACHE_KEY_POOLS, JSON.stringify({ ts: Date.now(), data })); } catch(e) {}
}

function loadPoolsCache() {
  try { const r = localStorage.getItem(CACHE_KEY_POOLS); return r ? JSON.parse(r) : null; } catch(e) { return null; }
}

function saveScoresCache(data) {
  try { localStorage.setItem(CACHE_KEY_SCORES, JSON.stringify({ ts: Date.now(), data, entries: chartEntries })); } catch(e) {}
}

function loadScoresCache() {
  try { const r = localStorage.getItem(CACHE_KEY_SCORES); return r ? JSON.parse(r) : null; } catch(e) { return null; }
}

function clearPoolsCache() {
  localStorage.removeItem(CACHE_KEY_POOLS);
  setStatus('Pools cache cleared — reloading...', 'loading');
  location.reload();
}

function clearScoresCache() {
  localStorage.removeItem(CACHE_KEY_SCORES);
  setStatus('Scores cache cleared — reloading...', 'loading');
  location.reload();
}

function updateCacheBadge(which, ts, ttl) {
  const dot = document.getElementById(`cacheDot${which}`);
  const lbl = document.getElementById(`cacheLabel${which}`);
  if (!dot || !lbl) return;
  if (!ts) { dot.className = 'dot'; lbl.textContent = `${which} LIVE`; return; }
  const age = Date.now() - ts;
  const mins = Math.floor(age / 60000);
  dot.className = age < ttl ? 'dot' : 'dot stale';
  lbl.textContent = mins < 1 ? `${which} <1m` : `${which} ${mins}m`;
}

// ─── FETCH ────────────────────────────────────────────────────────────────────
async function fetchCSV(url) {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), 30000);
  try {
    const r = await fetch(url, {
      redirect: 'follow',
      mode: 'cors',
      signal: controller.signal
    });
    clearTimeout(timeout);
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    const text = await r.text();
    console.log(`[fetchCSV] ${url.slice(-60)} => ${text.length} chars, starts: ${text.slice(0,80)}`);
    return text;
  } catch(e) {
    clearTimeout(timeout);
    console.error(`[fetchCSV] FAILED: ${url.slice(-60)}`, e.message);
    throw e;
  }
}



async function fetchPoolsData() {
  const allTabResults = [];

  const tasks = POOL_TABS.map((tab, tabIndex) => pool(async () => {
    const url = `${PROXY}?type=pools&gid=${tab.gid}`;
    try {
      const text = await fetchCSV(url);
      const rows = parseCSV(text);
      if (rows.length < 2) return;

      const headers = rows[0];
      const tabPools = [];

      for (let r = 1; r < rows.length; r++) {
        const row  = rows[r];
        const elo  = (row[0] || '').trim();
        const name = (row[1] || '').trim();
        if (!name && row.every(c => !c)) continue;

        const mapsByCategory = {};
        for (let c = 2; c < headers.length; c++) {
          const cat   = (headers[c] || '').trim();
          const mapId = (row[c] || '').trim();
          if (!cat || !mapId) continue;
          if (!mapsByCategory[cat]) mapsByCategory[cat] = [];
          mapsByCategory[cat].push(mapId);
        }
        tabPools.push({ name: name || `Pool ${r}`, elo, mapsByCategory });
      }

      allTabResults[tabIndex] = tabPools;
    } catch (e) {
      console.warn('Failed pools tab', tab.name, e);
    }
  }));

  await Promise.all(tasks);

  // Flatten in original tab order
  return allTabResults.flat().filter(Boolean);
}

async function fetchScoresData() {
  const result = {};
  const entries = []; // all dated rows for the activity chart

  // Launch ALL 12 tabs in parallel (pool limits to 4 at a time)
  const tasks = SCORE_TABS.map(tab => pool(async () => {
    try {
      const text = await fetchCSV(`${PROXY}?type=scores&gid=${tab.gid}`);
      const rows = parseCSV(text);
      let indexed = 0;

      rows.forEach(row => {
        const date  = (row[0] || '').trim();
        const mapId = (row[8] || '').trim();

        // Always capture dated rows for the activity chart (with full data for modal display)
        if (date) {
          const osuUrlEntry = (row[7] || '').trim();
          const setIdMatchEntry = osuUrlEntry.match(/beatmapsets\/(\d+)/);
          const beatmapsetIdEntry = setIdMatchEntry ? setIdMatchEntry[1] : '';
          entries.push({
            date,
            cat:        tab.name.replace(/[\d\/].*/, '').toLowerCase(),
            tabName:    tab.name,
            mapId:      mapId || '',
            image:      beatmapsetIdEntry ? `https://assets.ppy.sh/beatmaps/${beatmapsetIdEntry}/covers/cover.jpg` : '',
            name:       (row[2] || '').trim(),
            score:      (row[3] || '').trim(),
            difficulty: (row[4] || '').trim(),
            bpm:        (row[5] || '').trim(),
            comment:    (row[6] || '').trim(),
            osuUrl:     osuUrlEntry,
          });
        }

        // Only index rows with a valid map ID for pool display
        if (!mapId || !/^\d{5,10}$/.test(mapId)) return;

        const osuUrl = (row[7] || '').trim();
        const setIdMatch = osuUrl.match(/beatmapsets\/(\d+)/);
        const beatmapsetId = setIdMatch ? setIdMatch[1] : '';

        result[`${tab.name}:${mapId}`] = {
          image:      beatmapsetId
                        ? `https://assets.ppy.sh/beatmaps/${beatmapsetId}/covers/cover.jpg`
                        : '',
          name:       (row[2] || '').trim(),
          score:      (row[3] || '').trim(),
          difficulty: (row[4] || '').trim(),
          bpm:        (row[5] || '').trim(),
          comment:    (row[6] || '').trim(),
          date,
          cat:        tab.name.replace(/[\d\/].*/, '').toLowerCase(),
        };
        indexed++;
      });

      console.log(`[${tab.name}] ${rows.length} rows, ${indexed} indexed`);

      // Update status bar progressively
      const total = Object.keys(result).length;
      const el = document.getElementById('statusBar');
      if (el) {
        el.dataset.base = `Loading scores... ${total} indexed (${tab.name} ✓)`;
      }
    } catch (e) {
      console.warn(`[${tab.name}] failed:`, e.message);
    }
  }));

  await Promise.all(tasks);
  chartEntries = entries;
  return result;
}

// ─── INIT ────────────────────────────────────────────────────────────────────
async function init() {
  const cachedPools  = loadPoolsCache();
  const cachedScores = loadScoresCache();

  const needPools  = !cachedPools  || (Date.now() - cachedPools.ts)  >= CACHE_TTL_POOLS;
  const needScores = !cachedScores || (Date.now() - cachedScores.ts) >= CACHE_TTL_SCORES;

  // ── Render chart immediately from cache so it's always visible on page load ──
  if (cachedScores) {
    scoresMap = cachedScores.data;
    chartEntries = cachedScores.entries || [];
    renderActivityChart();
  }

  // Start timer
  const startTime = Date.now();
  let timerInterval = null;
  if (needPools || needScores) {
    timerInterval = setInterval(() => {
      const el = document.getElementById('statusBar');
      if (el) {
        const secs = ((Date.now() - startTime) / 1000).toFixed(1);
        // preserve existing message, just append time
        el.dataset.timer = secs;
        const base = el.dataset.base || el.textContent.replace(/ \(\d+\.\ds\)$/, '');
        el.dataset.base = base;
        el.textContent = `${base} (${secs}s)`;
      }
    }, 100);
  }

  const setStatusTimed = (msg, type) => {
    setStatus(msg, type);
    const el = document.getElementById('statusBar');
    if (el) el.dataset.base = msg;
  };

  // Fetch pools and scores in parallel where possible
  const poolsPromise = needPools
    ? fetchPoolsData()
        .then(data => { poolsData = data; savePoolsCache(data); updateCacheBadge('Pools', null, CACHE_TTL_POOLS); })
        .catch(e => {
          if (cachedPools) { poolsData = cachedPools.data; updateCacheBadge('Pools', cachedPools.ts, CACHE_TTL_POOLS); }
          else throw e;
        })
    : Promise.resolve().then(() => { poolsData = cachedPools.data; updateCacheBadge('Pools', cachedPools.ts, CACHE_TTL_POOLS); });

  const scoresPromise = needScores
    ? fetchScoresData()
        .then(data => {
          scoresMap = data;
          saveScoresCache(data);
          updateCacheBadge('Scores', null, CACHE_TTL_SCORES);
          renderActivityChart(); // update chart with fresh data
        })
        .catch(e => {
          if (cachedScores) { scoresMap = cachedScores.data; updateCacheBadge('Scores', cachedScores.ts, CACHE_TTL_SCORES); }
        })
    : Promise.resolve().then(() => { scoresMap = cachedScores.data; updateCacheBadge('Scores', cachedScores.ts, CACHE_TTL_SCORES); });

  setStatusTimed('Fetching data...', 'loading');

  try {
    await Promise.all([poolsPromise, scoresPromise]);
  } catch(e) {
    clearInterval(timerInterval);
    setStatus(`Error: ${e.message}`, 'error');
    return;
  }

  clearInterval(timerInterval);
  const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
  const suffix = (needPools || needScores) ? ` — loaded in ${elapsed}s` : '';
  setStatus(`${poolsData.length} pools · ${Object.keys(scoresMap).length} scores indexed${suffix}`, 'ok');
  setupSearch();
  // If no cache existed at all on first-ever load, render chart now (fresh fetch already fired renderActivityChart above)
  if (!cachedScores && !needScores) renderActivityChart();
}

// ─── SEARCH ───────────────────────────────────────────────────────────────────
function matchScore(str, query) {
  str = str.toLowerCase(); query = query.toLowerCase();
  if (str === query) return 0;                        // exact
  if (str.startsWith(query)) return 1;               // prefix
  if (str.includes(query)) return 2;                 // substring
  // fuzzy
  let si = 0, qi = 0;
  while (si < str.length && qi < query.length) { if (str[si] === query[qi]) qi++; si++; }
  return qi === query.length ? 3 : -1;               // fuzzy or no match
}

function setupSearch() {
  const input    = document.getElementById('poolSearch');
  const dropdown = document.getElementById('dropdown');
  let selectedIdx = -1;

  input.addEventListener('input', () => {
    const q = input.value.trim();
    if (!q) { dropdown.classList.remove('open'); return; }
    const matches = poolsData
      .map((p, i) => ({ p, i, score: matchScore(p.name, q) }))
      .filter(({ score }) => score >= 0)
      .sort((a, b) => a.score - b.score)
      .slice(0, 12);
    renderDropdown(matches, q);
    selectedIdx = -1;
  });

  input.addEventListener('keydown', e => {
    const items = dropdown.querySelectorAll('.dropdown-item');
    if (!items.length) return;
    if (e.key === 'ArrowDown') { e.preventDefault(); selectedIdx = (selectedIdx + 1) % items.length; }
    else if (e.key === 'ArrowUp') { e.preventDefault(); selectedIdx = (selectedIdx - 1 + items.length) % items.length; }
    else if (e.key === 'Enter') { if (selectedIdx >= 0) items[selectedIdx].click(); else if (items.length === 1) items[0].click(); return; }
    else if (e.key === 'Escape') { dropdown.classList.remove('open'); return; }
    items.forEach((el, i) => el.classList.toggle('active', i === selectedIdx));
  });

  document.addEventListener('click', e => { if (!e.target.closest('.search-wrapper')) dropdown.classList.remove('open'); });
}

function renderDropdown(matches, query) {
  const dropdown = document.getElementById('dropdown');
  if (!matches.length) {
    dropdown.innerHTML = '<div class="dropdown-item"><span class="pool-name" style="color:var(--text-dim)">No results found</span></div>';
  } else {
    dropdown.innerHTML = matches.map(({ p, i }) =>
      `<div class="dropdown-item" onclick="selectPool(${i})">
        <span class="pool-name">${highlight(p.name, query)}</span>
        <span class="pool-elo">${p.elo || ''}</span>
      </div>`
    ).join('');
  }
  dropdown.classList.add('open');
}

function highlight(str, query) {
  const idx = str.toLowerCase().indexOf(query.toLowerCase());
  if (idx < 0) return str;
  return str.slice(0, idx) +
    `<span style="color:var(--accent);font-weight:600">${str.slice(idx, idx + query.length)}</span>` +
    str.slice(idx + query.length);
}

// ─── POOL DISPLAY ─────────────────────────────────────────────────────────────
function removePool(blockId) {
  const block = document.getElementById(blockId);
  if (!block) return;

  // Find adjacent divider (after block if it exists, else before)
  const next = block.nextElementSibling;
  const prev = block.previousElementSibling;
  const divider = (next && next.classList.contains('pool-divider')) ? next
                : (prev && prev.classList.contains('pool-divider')) ? prev
                : null;

  const cleanup = () => {
    block.remove();
    if (divider) divider.remove();
    const container = document.getElementById('poolsContainer');
    if (!container.children.length) {
      document.getElementById('poolView').classList.remove('visible');
      document.getElementById('emptyState').style.display = '';
    }
  };

  block.classList.add('removing');
  if (divider) divider.classList.add('removing');
  block.addEventListener('animationend', cleanup, { once: true });
}

function selectPool(idx) {
  const pool = poolsData[idx];
  if (!pool) return;

  document.getElementById('poolSearch').value = pool.name;
  document.getElementById('dropdown').classList.remove('open');
  document.getElementById('emptyState').style.display = 'none';

  const container = document.getElementById('poolsContainer');
  const blockId = 'pool_' + Math.random().toString(36).slice(2);

  const totalMaps = Object.values(pool.mapsByCategory).reduce((a, b) => a + b.length, 0);
  const block = document.createElement('div');
  block.className = 'pool-block';
  block.id = blockId;
  block.innerHTML = `
    <div class="pool-block-header">
      <div class="pool-block-header-left">
        <div class="pool-title">${escHtml(pool.name)}</div>
        <div class="pool-meta">${pool.elo ? pool.elo + ' ELO · ' : ''}${totalMaps} maps</div>
      </div>
      <button class="pool-remove-btn" onclick="removePool('${blockId}')">✕ REMOVE</button>
    </div>
  `;

  // New pool goes to the top
  if (container.children.length > 0) {
    // Insert divider after the new block (between new and old)
    const divider = document.createElement('div');
    divider.className = 'pool-divider';
    divider.innerHTML = `<div class="pool-divider-line"></div><span class="pool-divider-label">↓ older</span><div class="pool-divider-line"></div>`;
    container.insertBefore(divider, container.firstChild);
    container.insertBefore(block, divider);
  } else {
    container.appendChild(block);
  }

  for (const [cat, mapIds] of Object.entries(pool.mapsByCategory)) {
    if (!mapIds.length) continue;
    const sheetName = cat.toLowerCase().replace(/\/.*/, '').replace(/\s/g, '');
    const matchedIds = mapIds.filter(id => scoresMap[`${sheetName}:${id}`]);
    if (!matchedIds.length) continue;
    const catKey = getCatKey(cat);
    const uid    = Math.random().toString(36).slice(2);
    const section = document.createElement('div');
    section.className = `category-section cat-${catKey}`;
    section.innerHTML = `
      <div class="category-header">
        <span class="category-pill">${cat}</span>
        <span class="category-count">${matchedIds.length} map${matchedIds.length !== 1 ? 's' : ''}</span>
      </div>
      <div class="map-list" id="ml_${uid}"></div>
    `;
    block.appendChild(section);

    const list = section.querySelector(`#ml_${uid}`);
    matchedIds.forEach((mapId, i) => {
      const rowEl = document.createElement('div');
      rowEl.className = 'map-row';
      rowEl.innerHTML = buildMapRow(mapId, sheetName, i + 1);
      list.appendChild(rowEl);
    });
  }

  document.getElementById('poolView').classList.add('visible');}

function buildMapRow(mapId, sheetName, index) {
  const s = scoresMap[`${sheetName}:${mapId}`] || {};

  // Cover: col B may be a URL or beatmapset ID; try it as-is
  const coverUrl = s.image || '';
  const coverHtml = coverUrl
    ? `<img src="${escHtml(coverUrl)}" alt="" onload="this.classList.add('loaded')" onerror="this.style.display='none'"/>`
    : '';

  const scoreColor = s.score ? getScoreColor(s.score) : '';
  const scoreHtml = s.score
    ? `<span class="map-score" style="color:${scoreColor}">${escHtml(s.score)}</span>`
    : `<span class="map-score" style="color:var(--text-dim)">—</span>`;

  const title = s.name
    ? escHtml(`${s.name} [${s.difficulty}]`)
    : `<span style="color:var(--text-dim)">${mapId}</span>`;

  const diffStr = s.difficulty ? escHtml(s.difficulty) : '';
  const bpmStr  = s.bpm ? escHtml(s.bpm) + ' BPM' : '';
  const subParts = [diffStr, bpmStr].filter(Boolean);
  const subHtml = subParts.length ? subParts.join(' <span class="map-sub-sep">|</span> ') : '';

  const commentHtml = s.comment
    ? `<div class="map-comment">${escHtml(s.comment)}</div>` : '';

  return `
    <div class="map-cover">
      <div class="map-cover-placeholder">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/>
          <polyline points="21 15 16 10 5 21"/>
        </svg>
      </div>
      ${coverHtml}
      <span class="map-num">#${index}</span>
    </div>
    <div class="map-body">
      <div class="map-title-row">
        <span class="map-title">${title}</span>
        <span class="map-sep">|</span>
        ${scoreHtml}
      </div>
      ${subHtml ? `<div class="map-sub-row">${subHtml}</div>` : ''}
      ${commentHtml}
    </div>
  `;
}

function getCatKey(cat) {
  const c = cat.toLowerCase();
  if (c.startsWith('nm')) return 'nm';
  if (c.startsWith('hd')) return 'hd';
  if (c.startsWith('hr')) return 'hr';
  if (c.startsWith('dt')) return 'dt';
  if (c.startsWith('fm')) return 'fm';
  if (c.startsWith('tb')) return 'tb';
  return 'nm';
}

function getScoreColor(scoreStr) {
  const n = parseFloat(String(scoreStr).replace(/,/g,'').replace(/[^0-9.]/g,''));
  if (isNaN(n)) return '';
  const clamped = Math.max(0, Math.min(1000000, n));

  // Define stops: 0=red, 250k=yellow, 500k=green, 750k=teal, 1m+=blue
  const stops = [
    { t: 0,       r: 235, g: 75,  b: 75  }, // red
    { t: 250000,  r: 235, g: 195, b: 75  }, // yellow
    { t: 500000,  r: 100, g: 220, b: 120 }, // green
    { t: 750000,  r: 75,  g: 210, b: 200 }, // teal
    { t: 1000000, r: 100, g: 160, b: 255 }, // blue
  ];

  let lo = stops[0], hi = stops[stops.length - 1];
  for (let i = 0; i < stops.length - 1; i++) {
    if (clamped >= stops[i].t && clamped <= stops[i+1].t) {
      lo = stops[i]; hi = stops[i+1]; break;
    }
  }
  const range = hi.t - lo.t || 1;
  const frac  = (clamped - lo.t) / range;
  const r = Math.round(lo.r + (hi.r - lo.r) * frac);
  const g = Math.round(lo.g + (hi.g - lo.g) * frac);
  const b = Math.round(lo.b + (hi.b - lo.b) * frac);
  return `rgb(${r},${g},${b})`;
}

function escHtml(str) {
  return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

function setStatus(msg, type = '') {
  const el = document.getElementById('statusBar');
  el.textContent = msg;
  el.className = 'status-bar ' + type;
}

// ─── CONCURRENCY LIMITER ─────────────────────────────────────────────────────
function createPool(concurrency) {
  const queue = [];
  let active = 0;

  function run() {
    while (active < concurrency && queue.length) {
      active++;
      const { fn, resolve, reject } = queue.shift();
      fn().then(resolve, reject).finally(() => { active--; run(); });
    }
  }

  return function enqueue(fn) {
    return new Promise((resolve, reject) => {
      queue.push({ fn, resolve, reject });
      run();
    });
  };
}

// Allow 4 simultaneous requests (safe for Apps Script)
const pool = createPool(4);

// ─── BATCH FETCH HELPER ──────────────────────────────────────────────────────
async function fetchBatchCSV(type, tabs) {
  const gids = tabs.map(t => t.gid).join(',');
  const url = `${PROXY}?type=${type}&gids=${gids}`;

  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), 60000); // 60s for batch

  try {
    const r = await fetch(url, {
      redirect: 'follow',
      mode: 'cors',
      signal: controller.signal
    });
    clearTimeout(timeout);
    if (!r.ok) throw new Error(`HTTP ${r.status}`);

    const text = await r.text();
    console.log('[fetchBatchCSV] response length:', text.length,
                'starts with:', text.slice(0, 80));

    // Parse JSON — the response is { "gid": "csv", "gid": "csv", ... }
    return JSON.parse(text);
  } catch(e) {
    clearTimeout(timeout);
    console.error('[fetchBatchCSV] FAILED:', e.message);
    throw e;
  }
}



// ─── REPLACE fetchScoresData ─────────────────────────────────────────────────
async function fetchScoresData() {
  const result = {};
  const entries = []; // all dated rows for the activity chart

  // ONE request fetches ALL 12 score tabs
  const batchData = await fetchBatchCSV('scores', SCORE_TABS);

  for (const tab of SCORE_TABS) {
    const csv = batchData[tab.gid];
    if (!csv) {
      console.warn(`[${tab.name}] no data in batch response for gid ${tab.gid}`);
      continue;
    }

    const rows = parseCSV(csv);
    let indexed = 0;

    rows.forEach(row => {
      const date  = (row[0] || '').trim();
      const mapId = (row[8] || '').trim();

      // Always capture dated rows for the activity chart (with full data for modal display)
      if (date) {
        const osuUrlEntry = (row[7] || '').trim();
        const setIdMatchEntry = osuUrlEntry.match(/beatmapsets\/(\d+)/);
        const beatmapsetIdEntry = setIdMatchEntry ? setIdMatchEntry[1] : '';
        entries.push({
          date,
          cat:      tab.name.replace(/[\d\/].*/, '').toLowerCase(),
          tabName:  tab.name,
          mapId:    mapId || '',
          image:    beatmapsetIdEntry ? `https://assets.ppy.sh/beatmaps/${beatmapsetIdEntry}/covers/cover.jpg` : '',
          name:     (row[2] || '').trim(),
          score:    (row[3] || '').trim(),
          difficulty: (row[4] || '').trim(),
          bpm:      (row[5] || '').trim(),
          comment:  (row[6] || '').trim(),
          osuUrl:   osuUrlEntry,
        });
      }

      // Only index rows with a valid map ID for pool display
      if (!mapId || !/^\d{5,10}$/.test(mapId)) return;

      const osuUrl = (row[7] || '').trim();
      const setIdMatch = osuUrl.match(/beatmapsets\/(\d+)/);
      const beatmapsetId = setIdMatch ? setIdMatch[1] : '';

      result[`${tab.name}:${mapId}`] = {
        image:      beatmapsetId
                      ? `https://assets.ppy.sh/beatmaps/${beatmapsetId}/covers/cover.jpg`
                      : '',
        name:       (row[2] || '').trim(),
        score:      (row[3] || '').trim(),
        difficulty: (row[4] || '').trim(),
        bpm:        (row[5] || '').trim(),
        comment:    (row[6] || '').trim(),
        date,
        cat:        tab.name.replace(/[\d\/].*/, '').toLowerCase(),
      };
      indexed++;
    });

    console.log(`[${tab.name}] ${rows.length} rows, ${indexed} indexed`);
    const total = Object.keys(result).length;
    const el = document.getElementById('statusBar');
    if (el) { el.dataset.base = `Loading scores... ${total} indexed (${tab.name} ✓)`; }
  }

  chartEntries = entries;
  return result;
}


// ─── REPLACE fetchPoolsData ──────────────────────────────────────────────────
async function fetchPoolsData() {
  const result = [];

  // ONE request fetches ALL 4 pool tabs
  const batchData = await fetchBatchCSV('pools', POOL_TABS);

  for (const tab of POOL_TABS) {
    const csv = batchData[tab.gid];
    if (!csv) {
      console.warn(`[${tab.name}] no data in batch for gid ${tab.gid}`);
      continue;
    }

    const rows = parseCSV(csv);
    if (rows.length < 2) continue;
    const headers = rows[0];

    for (let r = 1; r < rows.length; r++) {
      const row  = rows[r];
      const elo  = (row[0] || '').trim();
      const name = (row[1] || '').trim();
      if (!name && row.every(c => !c)) continue;

      const mapsByCategory = {};
      for (let c = 2; c < headers.length; c++) {
        const cat   = (headers[c] || '').trim();
        const mapId = (row[c] || '').trim();
        if (!cat || !mapId) continue;
        if (!mapsByCategory[cat]) mapsByCategory[cat] = [];
        mapsByCategory[cat].push(mapId);
      }
      result.push({ name: name || `Pool ${r}`, elo, mapsByCategory });
    }
  }

  return result;
}

// ─── ACTIVITY CHART ──────────────────────────────────────────────────────────
const CAT_COLORS = {
  nm: 'var(--nm)',
  hd: 'var(--hd)',
  hr: 'var(--hr)',
  dt: 'var(--dt)',
  fm: 'var(--fm)',
  tb: 'var(--tb)',
};
const CAT_ORDER = ['nm', 'hd', 'hr', 'dt', 'fm', 'tb'];

function parseScoreDate(dateStr) {
  if (!dateStr) return null;
  // Try various formats: MM/DD/YYYY, YYYY-MM-DD, M/D/YYYY, etc.
  const s = dateStr.trim();
  // ISO
  let d = new Date(s);
  if (!isNaN(d)) return d;
  // MM/DD/YYYY or M/D/YYYY
  const mdy = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
  if (mdy) { d = new Date(+mdy[3], +mdy[1]-1, +mdy[2]); if (!isNaN(d)) return d; }
  return null;
}

function renderActivityChart() {
  const section = document.getElementById('activitySection');
  const chartEl = document.getElementById('activityChart');
  const labelsEl = document.getElementById('activityXLabels');
  const legendEl = document.getElementById('activityLegend');
  if (!section || !chartEl) return;

  // Build 30-day bucket array — track both category totals AND per-tab counts
  const today = new Date();
  today.setHours(0,0,0,0);
  const days = [];
  for (let i = 29; i >= 0; i--) {
    const d = new Date(today);
    d.setDate(today.getDate() - i);
    days.push({ date: d, counts: {}, tabs: {} });
    // counts: { nm: 5, hd: 3, ... }
    // tabs:   { nm: { nm1: 2, nm2: 3 }, hd: { hd1: 1, hd2: 2 }, ... }
  }

  // Fill from chartEntries — includes ALL dated rows, even those without a valid map ID
  let anyDate = false;
  chartEntries.forEach(s => {
    if (!s.date) return;
    const d = parseScoreDate(s.date);
    if (!d) return;
    d.setHours(0,0,0,0);
    const diff = Math.round((d - days[0].date) / 86400000);
    if (diff < 0 || diff >= 30) return;

    const tabName = s.tabName || '';
    const cat = (s.cat || tabName.replace(/[\d\/].*/, '') || 'nm').toLowerCase();

    const day = days[diff];
    day.counts[cat] = (day.counts[cat] || 0) + 1;
    if (!day.tabs[cat]) day.tabs[cat] = {};
    day.tabs[cat][tabName] = (day.tabs[cat][tabName] || 0) + 1;
    anyDate = true;
  });

  if (!anyDate) {
    section.style.display = 'none';
    return;
  }

  section.style.display = '';

  const totals = days.map(d => Object.values(d.counts).reduce((a,b) => a+b, 0));
  const maxTotal = Math.max(...totals, 1);
  const activeCats = CAT_ORDER.filter(cat => days.some(d => d.counts[cat]));
  const tooltip = document.getElementById('activityTooltip');

  chartEl.innerHTML = '';
  labelsEl.innerHTML = '';
  legendEl.innerHTML = '';

  // Helper: show tooltip
  function showTooltip(e, html) {
    tooltip.innerHTML = html;
    tooltip.style.display = 'block';
    positionTooltip(e);
  }
  function positionTooltip(e) {
    const tw = tooltip.offsetWidth || 160;
    const th = tooltip.offsetHeight || 80;
    let x = e.clientX + 14;
    let y = e.clientY - 10;
    if (x + tw > window.innerWidth - 8) x = e.clientX - tw - 14;
    if (y + th > window.innerHeight - 8) y = e.clientY - th - 10;
    tooltip.style.left = x + 'px';
    tooltip.style.top  = y + 'px';
  }
  function hideTooltip() { tooltip.style.display = 'none'; }

  days.forEach((day, i) => {
    const total = totals[i];
    const dateLabel = day.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    const col = document.createElement('div');
    col.className = 'activity-bar-col';

    if (total === 0) {
      const empty = document.createElement('div');
      empty.className = 'activity-bar-empty';
      // Empty day tooltip
      empty.addEventListener('mouseenter', e => {
        showTooltip(e, `<div style="color:var(--text-bright);margin-bottom:2px">${dateLabel}</div><div style="color:var(--text-dim)">no scores</div>`);
      });
      empty.addEventListener('mousemove', positionTooltip);
      empty.addEventListener('mouseleave', hideTooltip);
      col.appendChild(empty);
    } else {
      const segs = [];
      CAT_ORDER.forEach(cat => {
        const count = day.counts[cat] || 0;
        if (!count) return;
        const heightPct = (count / maxTotal) * 100;
        const seg = document.createElement('div');
        seg.className = 'activity-bar-seg';
        seg.style.height = heightPct + '%';
        seg.style.background = CAT_COLORS[cat] || 'var(--nm)';
        seg.style.cursor = 'pointer';

        // Per-segment hover: show tab breakdown for this category
        const tabData = day.tabs[cat] || {};
        const tabNames = Object.keys(tabData).sort();

        seg.addEventListener('click', e => {
          e.stopPropagation();
          hideTooltip();
          openScoreModal(dateLabel, day.date, cat, tabNames);
        });

        seg.addEventListener('mouseenter', e => {
          e.stopPropagation();
          seg.classList.add('hovered');
          let html = `<div style="color:var(--text-bright);margin-bottom:6px">${dateLabel}</div>`;
          html += `<div style="color:${CAT_COLORS[cat]};font-weight:600;margin-bottom:4px;letter-spacing:0.08em">${cat.toUpperCase()}  <span style="color:var(--text-bright)">${count}</span></div>`;
          if (tabNames.length > 1) {
            tabNames.forEach(tab => {
              html += `<div style="padding-left:8px;color:var(--text-dim)">${tab}<span style="color:var(--text);margin-left:8px">${tabData[tab]}</span></div>`;
            });
          } else if (tabNames.length === 1) {
            // Only one tab — still show it for clarity
            html += `<div style="padding-left:8px;color:var(--text-dim)">${tabNames[0]}<span style="color:var(--text);margin-left:8px">${tabData[tabNames[0]]}</span></div>`;
          }
          if (total > count) {
            html += `<div style="border-top:1px solid var(--border);margin-top:6px;padding-top:6px;color:var(--text-dim)">day total  <span style="color:var(--text-bright)">${total}</span></div>`;
          }
          html += `<div style="margin-top:6px;color:var(--accent);font-size:0.62rem;letter-spacing:0.08em">CLICK TO VIEW SCORES</div>`;
          showTooltip(e, html);
        });
        seg.addEventListener('mousemove', positionTooltip);
        seg.addEventListener('mouseleave', () => { seg.classList.remove('hovered'); hideTooltip(); });

        segs.push(seg);
      });

      // Append in reverse so NM is at bottom (flex-col items stack top-down)
      segs.reverse().forEach(s => col.appendChild(s));
      if (col.firstChild) col.firstChild.style.borderRadius = '3px 3px 0 0';

      // Column-level fallthrough (gaps between segs) — show day summary
      col.addEventListener('mouseenter', e => {
        // Only fire if not already handled by a segment
        if (e.target !== col) return;
        let html = `<div style="color:var(--text-bright);margin-bottom:4px">${dateLabel}</div>`;
        CAT_ORDER.forEach(cat => {
          const count = day.counts[cat] || 0;
          if (!count) return;
          html += `<div><span style="color:${CAT_COLORS[cat]}">${cat.toUpperCase()}</span>  <span style="color:var(--text)">${count}</span></div>`;
        });
        html += `<div style="border-top:1px solid var(--border);margin-top:4px;padding-top:4px;color:var(--text-bright)">total  ${total}</div>`;
        showTooltip(e, html);
      });
      col.addEventListener('mousemove', e => { if (e.target === col) positionTooltip(e); });
      col.addEventListener('mouseleave', hideTooltip);
    }

    chartEl.appendChild(col);

    const label = document.createElement('div');
    label.className = 'activity-x-label';
    if (i % 5 === 0 || i === 29) {
      label.textContent = day.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    }
    labelsEl.appendChild(label);
  });

  // Legend
  activeCats.forEach(cat => {
    const item = document.createElement('div');
    item.className = 'activity-legend-item';
    item.innerHTML = `<div class="activity-legend-dot" style="background:${CAT_COLORS[cat]}"></div>${cat.toUpperCase()}`;
    legendEl.appendChild(item);
  });
}

// ─── SCORE DRILL-DOWN MODAL ───────────────────────────────────────────────────
function isSameDay(a, b) {
  return a.getFullYear() === b.getFullYear() &&
         a.getMonth()    === b.getMonth()    &&
         a.getDate()     === b.getDate();
}

function buildModalMapRow(entry, index) {
  // Prefer scoresMap for richer data if available, merge with chartEntry
  const sm = (entry.mapId && scoresMap[`${entry.tabName}:${entry.mapId}`]) || {};
  const s = {
    image:      sm.image      || entry.image      || '',
    name:       sm.name       || entry.name       || '',
    score:      sm.score      || entry.score      || '',
    difficulty: sm.difficulty || entry.difficulty || '',
    bpm:        sm.bpm        || entry.bpm        || '',
    comment:    sm.comment    || entry.comment    || '',
  };

  const osuUrl = entry.osuUrl || (entry.mapId ? `https://osu.ppy.sh/b/${entry.mapId}` : '');

  const coverUrl = s.image || '';
  const coverHtml = coverUrl
    ? `<img src="${escHtml(coverUrl)}" alt="" onload="this.classList.add('loaded')" onerror="this.style.display='none'"/>`
    : '';

  const scoreColor = s.score ? getScoreColor(s.score) : '';
  const scoreHtml = s.score
    ? `<span class="map-score" style="color:${scoreColor}">${escHtml(s.score)}</span>`
    : `<span class="map-score" style="color:var(--text-dim)">—</span>`;

  let titleInner;
  if (s.name) {
    titleInner = escHtml(`${s.name}${s.difficulty ? ' [' + s.difficulty + ']' : ''}`);
  } else if (osuUrl) {
    titleInner = `<a href="${escHtml(osuUrl)}" target="_blank" rel="noopener"
      style="color:var(--accent);text-decoration:none;font-family:'DM Mono',monospace;font-size:0.85rem"
      onclick="event.stopPropagation()">
      ${entry.mapId || 'open beatmap'} ↗
    </a>`;
  } else {
    titleInner = `<span style="color:var(--text-dim)">unknown map</span>`;
  }

  const bpmStr  = s.bpm ? escHtml(s.bpm) + ' BPM' : '';
  const diffStr = s.difficulty ? escHtml(s.difficulty) : '';
  const subParts = [diffStr, bpmStr].filter(Boolean);
  const subHtml = subParts.length ? subParts.join(' <span class="map-sub-sep">|</span> ') : '';
  const commentHtml = s.comment ? `<div class="map-comment">${escHtml(s.comment)}</div>` : '';

  const rowStyle = osuUrl
    ? `cursor:pointer; title="${escHtml(osuUrl)}"` 
    : '';
  const rowClick = osuUrl
    ? `onclick="window.open('${escHtml(osuUrl)}','_blank')"` 
    : '';

  return `
    <div class="map-cover">
      <div class="map-cover-placeholder">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/>
          <polyline points="21 15 16 10 5 21"/>
        </svg>
      </div>
      ${coverHtml}
      <span class="map-num">#${index}</span>
    </div>
    <div class="map-body" ${rowClick} style="${osuUrl ? 'cursor:pointer' : ''}">
      <div class="map-title-row">
        <span class="map-title">${titleInner}</span>
        <span class="map-sep">|</span>
        ${scoreHtml}
      </div>
      ${subHtml ? `<div class="map-sub-row">${subHtml}</div>` : ''}
      ${commentHtml}
    </div>
  `;
}

function openScoreModal(dateLabel, dayDate, cat, tabNames) {
  const backdrop = document.getElementById('scoreModalBackdrop');
  const title    = document.getElementById('scoreModalTitle');
  const meta     = document.getElementById('scoreModalMeta');
  const body     = document.getElementById('scoreModalBody');

  title.textContent = `${cat.toUpperCase()} · ${dateLabel}`;
  title.style.color = CAT_COLORS[cat] || 'var(--text-bright)';
  body.innerHTML = '';

  let totalShown = 0;

  tabNames.forEach(tabName => {
    // Use chartEntries as source — has ALL rows with dates regardless of map ID validity
    const matching = chartEntries.filter(e => {
      if (e.tabName !== tabName) return false;
      const d = parseScoreDate(e.date);
      if (!d) return false;
      d.setHours(0, 0, 0, 0);
      return isSameDay(d, dayDate);
    });

    if (!matching.length) return;

    const section = document.createElement('div');
    section.className = `score-modal-tab-section category-section cat-${cat}`;

    const header = document.createElement('div');
    header.className = 'score-modal-tab-header category-header';
    header.innerHTML = `
      <span class="category-pill">${tabName}</span>
      <span class="category-count">${matching.length} map${matching.length !== 1 ? 's' : ''}</span>
    `;
    section.appendChild(header);

    const list = document.createElement('div');
    list.className = 'map-list';

    matching.forEach((entry, i) => {
      const rowEl = document.createElement('div');
      rowEl.className = 'map-row';
      rowEl.innerHTML = buildModalMapRow(entry, i + 1);
      list.appendChild(rowEl);
      totalShown++;
    });

    section.appendChild(list);
    body.appendChild(section);
  });

  meta.textContent = totalShown ? `${totalShown} score${totalShown !== 1 ? 's' : ''}` : '';
  backdrop.style.display = 'flex';
  document.body.style.overflow = 'hidden';
}

function closeScoreModal() {
  const backdrop = document.getElementById('scoreModalBackdrop');
  backdrop.style.display = 'none';
  document.body.style.overflow = '';
}

function handleModalBackdropClick(e) {
  if (e.target === document.getElementById('scoreModalBackdrop')) closeScoreModal();
}

document.addEventListener('keydown', e => {
  if (e.key === 'Escape') closeScoreModal();
});

// ─── START ────────────────────────────────────────────────────────────────────
init();
</script>
</body>
</html>
